esphome:
  name: esphome-web-1d95ee
  friendly_name: D1Mini_WindIndicator
  min_version: 2025.9.0
  name_add_mac_suffix: false

esp8266:
  board: d1_mini
  restore_from_flash: true

# Enable logging
logger:

# Enable Home Assistant API
api:
  # Triggered when Home Assistant disconnects (or Wi-Fi drops)
  on_client_disconnected:
    - logger.log: "Home Assistant disconnected! Safety shutdown triggered."
    - output.set_level:
        id: pwm_output
        level: 0.0

# Allow Over-The-Air updates
ota:
- platform: esphome

wifi:
  min_auth_mode: WPA2
  ssid: !secret wifi_ssid
  password: !secret wifi_password

# --- Globals for State Management ---
globals:
  - id: is_gust_mode
    type: bool
    restore_value: false
    initial_value: 'false' # False = Wind Speed, True = Wind Gust
  - id: last_transition_time
    type: int
    restore_value: false
    initial_value: '0'


light:
  # Built-in LED showing status
  - platform: status_led
    id: builtin_led
    name: "Built-in LED"
    internal: true
    restore_mode: RESTORE_DEFAULT_ON
    pin:
      number: D4
      inverted: True
  # Red LED for weather beacon
  - platform: monochromatic
    id: red_led
    output: pwm_red_led
    internal: true
    default_transition_length: 500ms
  # Blue LED for weather beacon
  - platform: monochromatic
    id: blue_led
    output: pwm_blue_led
    internal: true
    default_transition_length: 500ms


output:
  # PWM output to drive the wind indicator
  - platform: esp8266_pwm
    pin: D1 # Pin D1 / GPIO5
    frequency: 1000 Hz
    id: pwm_output
    min_power: 0
    max_power: 0.77
  # PWM for blue LED
  - platform: esp8266_pwm
    pin: D7
    frequency: 1000 Hz
    id: pwm_blue_led
  # PWM for red LED
  - platform: esp8266_pwm
    pin: D8
    frequency: 1000 Hz
    id: pwm_red_led

# Switch exposed to HA to turn the
# built-in led on when gust speed is shown
switch:
  - platform: template
    name: "Status LED"
    id: led_switch
    optimistic: true
  - platform: template
    name: "Weather LEDs"
    id: weather_leds_switch
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON

number:
  - platform: template
    name: "Red LED Brightness"
    id: red_led_brightness
    min_value: 0
    max_value: 100
    step: 1
    initial_value: 100
    restore_value: true
    optimistic: true
    unit_of_measurement: "%"

  - platform: template
    name: "Blue LED Brightness"
    id: blue_led_brightness
    min_value: 0
    max_value: 100
    step: 1
    initial_value: 35
    restore_value: true
    optimistic: true
    unit_of_measurement: "%"

# Define the common filters for normalization
# This anchor allows us to reuse the filter list
.common_wind_filters:
  calibration_curve: &calibration_curve
    # The scale is not entirely linear so use
  # a calibration curve.
    calibrate_linear:
      method: exact # linear interpolation mode
      datapoints:
            # Map from sensor value to output value
        - 0.0 -> 0.0
        - 4 -> 0.011
        - 6 -> 0.043
        - 8 -> 0.075
        - 10 -> 0.106
        - 12 -> 0.138
        - 14 -> 0.180
        - 16 -> 0.217
        - 18 -> 0.264
        - 20 -> 0.296
        - 22 -> 0.343
        - 24 -> 0.374
        - 26 -> 0.422
        - 28 -> 0.469
        - 30 -> 0.500
        - 32 -> 0.548
        - 34 -> 0.595
        - 36 -> 0.643
        - 38 -> 0.690
        - 40 -> 0.737
        - 42 -> 0.785
        - 44 -> 0.832
        - 46 -> 0.879
        - 48 -> 0.942
        - 50 -> 1

  # Clamp the value from 0 to 1
  clamp_logic: &clamp_logic
    lambda: |-
      // Clamp the value to ensure it never exceeds 0.0 - 1.0 range
      if (x > 1.0) return 1.0;
      if (x < 0.0) return 0.0;
      return x;

sensor:
  # Normalized Wind Speed Sensor (Internal)
  - platform: homeassistant
    id: ha_wind_speed_norm
    #entity_id: input_number.test_fake_wind_speed
    entity_id: sensor.pirateweather_wind_speed
    internal: true
    filters:
      - *calibration_curve
      - *clamp_logic

  # Normalized Wind Gust Sensor (Internal)
  - platform: homeassistant
    id: ha_wind_gust_norm
    #entity_id: input_number.test_fake_wind_gust
    entity_id: sensor.pirateweather_wind_gust
    internal: true
    filters:
      - *calibration_curve
      - *clamp_logic

  # Daytime max temp today
  - platform: homeassistant
    id: ha_daytime_high_temp
    entity_id: sensor.pirateweather_daytime_high_apparent_temperature_0d
    internal: true

  # Precipitation probability today
  - platform: homeassistant
    id: ha_precipitation_prob
    entity_id: sensor.pirateweather_precip_probability_0d
    internal: true

interval:
  - interval: 0.5s
    then:
      - lambda: |-
          // Define a static variable to track the last time we CHECKED for a transition.
          // This persists between lambda calls.
          static uint32_t last_check_time = 0;
          uint32_t now = millis();

          // =========================================================
          // 1. STATE TRANSITION LOGIC (Runs only every 1000ms/1s)
          // =========================================================
          if (now - last_check_time >= 1000) {
            last_check_time = now;
            
            // Calculate time since the state LAST CHANGED
            uint32_t time_since_transition = now - id(last_transition_time);
            
            // Only attempt transition if we passed the 2 second lock
            if (time_since_transition > 2000) {
              float probability = 0.0;
              
              if (id(is_gust_mode)) {
                // --- CURRENT: GUST -> GOING TO: SPEED ---
                // Target: 5 seconds total. Lockout: 2s. Ramp: 4s.
                if (time_since_transition >= 6000) {
                  probability = 1.0;
                } else {
                  probability = (time_since_transition - 2000.0) / 3000.0;
                }
              } else {
                // --- CURRENT: SPEED -> GOING TO: GUST ---
                // Target: 10 seconds total. Lockout: 2s. Ramp: 12s.
                if (time_since_transition >= 14000) {
                  probability = 1.0;
                } else {
                  probability = (time_since_transition - 2000.0) / 8000.0;
                }
              }

              // Roll the dice
              float roll = (float)rand() / RAND_MAX;
              
              if (roll < probability) {
                id(is_gust_mode) = !id(is_gust_mode);
                id(last_transition_time) = now;
                ESP_LOGD("main", "Transitioned to %s. (Prob: %.2f, Time: %u ms)", 
                  id(is_gust_mode) ? "GUST" : "SPEED", probability, time_since_transition);
              }
            }
          }

          // =========================================================
          // 2. PWM & JITTER LOGIC (Runs every 0.5s)
          // =========================================================
          
          float speed_value = id(ha_wind_speed_norm).state;
          float gust_value = id(ha_wind_gust_norm).state;
          if (std::isnan(speed_value)) speed_value = 0.0;
          if (std::isnan(gust_value)) gust_value = 0.0;

          float target_level;

          if (id(is_gust_mode)) {
            // Gust Mode Jitter (0.75 - 1.0)
            float random_factor_gust = ((double) rand() / RAND_MAX) * 0.25 + 0.75;
            target_level = gust_value * random_factor_gust;
            
            if (id(led_switch).state) {
              id(builtin_led).turn_on().perform();
            }
          } else {
            // Speed Mode Jitter (0.9 - 1.1)
            float random_factor_speed = ((double) rand() / RAND_MAX) * 0.2 + 0.9;
            target_level = speed_value * random_factor_speed;
            
            id(builtin_led).turn_off().perform();
          }

          id(pwm_output).set_level(target_level);

          // =========================================================
          // 3. Weather LEDs
          // Rules:
          // - If HighTemp > 10ºC and no precip -> Blue solid
          // - If 0 < HighTemp < 10ºC -> Red solid
          // - If HighTemp < 0ºC -> Blink red
          // - If precipitation prob > 15% -> Blink Blue
          // =========================================================

          float high_temp = id(ha_daytime_high_temp).state;
          float precipitation_prob = id(ha_precipitation_prob).state;
          if (std::isnan(high_temp)) high_temp = 0.0;
          if (std::isnan(precipitation_prob)) precipitation_prob = 0.0;

          if (!id(weather_leds_switch).state) {
            // Weather LEDs disabled — ensure both are off
            id(red_led).turn_off().perform();
            id(blue_led).turn_off().perform();
          } else {
            float red_brightness  = id(red_led_brightness).state  / 100.0f;
            float blue_brightness = id(blue_led_brightness).state / 100.0f;

            // Red LED control
            if (high_temp >= 10) {
              id(red_led).turn_off().perform();
              ESP_LOGD("main", "Red OFF");
            } else if (high_temp < 10 && high_temp > 0) {
              id(red_led).turn_on().set_brightness(red_brightness).perform();
              ESP_LOGD("main", "Red ON");
            } else if (high_temp <= 0) {
              ESP_LOGD("main", "Red BLINK");
              if ((millis() / 1000) % 2 == 1) {
                id(red_led).turn_on().set_brightness(red_brightness).perform();
              } else {
                id(red_led).turn_off().perform();
              }
            }

            // Blue LED Control
            if (high_temp >= 10 && precipitation_prob < 15) {
              id(blue_led).turn_on().set_brightness(blue_brightness).perform();
              ESP_LOGD("main", "Blue ON");
            } else if (precipitation_prob >= 15) {
              if ((millis() / 1000) % 2 == 1) {
                id(blue_led).turn_on().set_brightness(blue_brightness).perform();
              } else {
                id(blue_led).turn_off().perform();
              }
              ESP_LOGD("main", "Blue BLINK");
            } else {
              id(blue_led).turn_off().perform();
              ESP_LOGD("main", "Blue OFF");
            }
          }