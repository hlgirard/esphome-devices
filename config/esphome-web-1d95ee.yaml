esphome:
  name: esphome-web-1d95ee
  friendly_name: D1Mini_WindIndicator
  min_version: 2025.9.0
  name_add_mac_suffix: false

esp8266:
  board: d1_mini

# Enable logging
logger:

# Enable Home Assistant API
api:
  # Triggered when Home Assistant disconnects (or Wi-Fi drops)
  on_client_disconnected:
    - logger.log: "Home Assistant disconnected! Safety shutdown triggered."
    - output.set_level:
        id: pwm_output
        level: 0.0

# Allow Over-The-Air updates
ota:
- platform: esphome

wifi:
  min_auth_mode: WPA2
  ssid: !secret wifi_ssid
  password: !secret wifi_password

# --- Globals for State Management ---
globals:
  - id: is_gust_mode
    type: bool
    restore_value: false
    initial_value: 'false' # False = Wind Speed, True = Wind Gust
  - id: last_transition_time
    type: int
    restore_value: false
    initial_value: '0'

output:
  - platform: esp8266_pwm
    pin: D1 # Pin D1 / GPIO5
    frequency: 1000 Hz
    id: pwm_output
    min_power: 0
    max_power: 0.77

light:
  - platform: status_led
    id: builtin_led
    name: "Built-in LED"
    internal: true
    restore_mode: RESTORE_DEFAULT_ON
    pin:
      number: D4
      inverted: True

switch:
  - platform: template
    name: "LED Switch"
    id: led_switch
    optimistic: true

# Define the common filters for normalization
# This anchor allows us to reuse the filter list
.common_wind_filters:
  calibration_curve: &calibration_curve
    # The scale is not entirely linear so use
  # a calibration curve.
    calibrate_linear:
      method: exact # linear interpolation mode
      datapoints:
            # Map from sensor value to output value
        - 0.0 -> 0.0
        - 4 -> 0.011
        - 6 -> 0.043
        - 8 -> 0.075
        - 10 -> 0.106
        - 12 -> 0.138
        - 14 -> 0.180
        - 16 -> 0.217
        - 18 -> 0.264
        - 20 -> 0.296
        - 22 -> 0.343
        - 24 -> 0.374
        - 26 -> 0.422
        - 28 -> 0.469
        - 30 -> 0.500
        - 32 -> 0.548
        - 34 -> 0.595
        - 36 -> 0.643
        - 38 -> 0.690
        - 40 -> 0.737
        - 42 -> 0.785
        - 44 -> 0.832
        - 46 -> 0.879
        - 48 -> 0.942
        - 50 -> 1

  # Clamp the value from 0 to 1
  clamp_logic: &clamp_logic
    lambda: |-
      // Clamp the value to ensure it never exceeds 0.0 - 1.0 range
      if (x > 1.0) return 1.0;
      if (x < 0.0) return 0.0;
      return x;

sensor:
  # Normalized Wind Speed Sensor (Internal)
  - platform: homeassistant
    id: ha_wind_speed_norm
    #entity_id: input_number.test_fake_wind_speed
    entity_id: sensor.pirateweather_wind_speed
    internal: true
    filters:
      - *calibration_curve
      - *clamp_logic

  # Normalized Wind Gust Sensor (Internal)
  - platform: homeassistant
    id: ha_wind_gust_norm
    #entity_id: input_number.test_fake_wind_gust
    entity_id: sensor.pirateweather_wind_gust
    internal: true
    filters:
      - *calibration_curve
      - *clamp_logic

interval:
  - interval: 0.5s
    then:
      - lambda: |-
          // 1. Get current values
          float speed_value = id(ha_wind_speed_norm).state;
          float gust_value = id(ha_wind_gust_norm).state;

          // Handle potential NaN values (e.g., before first update)
          if (std::isnan(speed_value)) speed_value = 0.0;
          if (std::isnan(gust_value)) gust_value = 0.0;

          // 2. State Transition Logic
          uint32_t now = millis();
          uint32_t time_since = now - id(last_transition_time);
          
          // Only attempt transition if we passed the 2 second lock
          if (time_since > 2000) {
            float probability = 0.0;
            
            if (id(is_gust_mode)) {
              // --- CURRENT: GUST -> GOING TO: SPEED ---
              // Target: 5 seconds total.
              // Lockout: 2s. Ramp window: 3s (5000ms - 2000ms).
              if (time_since >= 5000) {
                probability = 1.0;
              } else {
                probability = (time_since - 2000.0) / 3000.0;
              }
            } else {
              // --- CURRENT: SPEED -> GOING TO: GUST ---
              // Target: 10 seconds total.
              // Lockout: 2s. Ramp window: 8s (10000ms - 2000ms).
              if (time_since >= 10000) {
                probability = 1.0;
              } else {
                probability = (time_since - 2000.0) / 8000.0;
              }
            }

            // Roll the dice (0.0 to 1.0)
            float roll = (float) rand() / RAND_MAX;
            
            if (roll < probability) {
              // Switch state
              id(is_gust_mode) = !id(is_gust_mode);
              id(last_transition_time) = now;
              ESP_LOGD("main", "Transitioned to %s. (Prob: %.2f, Time: %u ms)", 
                id(is_gust_mode) ? "GUST" : "SPEED", probability, time_since);
            }
          }

          // 3. Set Output based on global State
          float target_level;

          if (id(is_gust_mode)) {
            // Gust Mode Logic
            float random_factor_gust = ((double) rand() / RAND_MAX) * 0.25 + 0.75;
            target_level = gust_value * random_factor_gust;
            
            // LED ON indicates Gust
            if (id(led_switch).state) {
              id(builtin_led).turn_on().perform();
            }
          } else {
            // Speed Mode Logic
            float random_factor_speed = ((double) rand() / RAND_MAX) * 0.2 + 0.9;
            target_level = speed_value * random_factor_speed;
            
            // LED OFF indicates Speed
            id(builtin_led).turn_off().perform();
          }

          id(pwm_output).set_level(target_level);